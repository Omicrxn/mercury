[{"title":"Getting Started","href":"/docs/getting-started","description":"Seamlessly integrate your favorite animation libraries (Motion, AnimeJS, GSAP) into your Svelte projects using Mercury.","content":"  import { Callout } from \"@svecodocs/kit\";  import { PMCommand } from '$lib/components/ui/pm-command';   The following guide will walk you through the process of installing Mercury.  Installation  You can easily install Mercury with npm or your preferred package manager:  Animating Elements  Mercury leverages Svelte Attachments to provide intuitive animation handling. Here’s a basic example demonstrating its usage:   "},{"title":"Introduction","href":"/docs/index","description":"What is Mercury?","content":"  import { Callout } from '@svecodocs/kit'   Mercury is an animation library designed specifically for Svelte, created to bring powerful, expressive motion into modern Svelte applications—without adding unnecessary complexity or breaking away from Svelte’s core principles.  Many existing animation solutions for Svelte either offer limited functionality, are deprecated or introduce awkward abstractions. Libraries like Framer Motion set a high bar for motion design in React, but adapting those patterns to Svelte often results in unexpected results and bloated code.  Mercury was built to solve this gap.  Purpose  Mercury aims to bring layout-aware, fine-grained animations to Svelte in a way that feels native. It focuses on:  Attachment-based control** – Animations are declared using Svelte attachments, allowing direct manipulation of DOM elements without extra components or wrappers. Shared layout transitions** – Mercury enables elements to animate seamlessly across layouts using layoutIds, making complex interactions feel effortless. Presence animations** – Full support for presence animations brings component mount/unmount animations similar to what Framer Motion offers, but in a Svelte-native way. Minimal friction** – The API is designed to be declarative, composable, and minimal. It scales from simple transitions to advanced UI flows without boilerplate. Compatibility** - Mercury is engine-agnostic. Whether you prefer AnimeJS, Motion, or GSAP, Mercury lets you plug in your preferred animation engine while handling the coordination logic. This means you can continue using utilities, motion values, and other features from those libraries seamlessly alongside Mercury.  Philosophy  The core philosophy behind Mercury is to enable expressive animation without compromising the clarity or structure of Svelte code. It builds upon Svelte’s strengths rather than abstracting them away, offering a motion system that is:  Predictable** – Built on motion values, transitions, and layout projections that behave consistently. Flexible** – Easily integrated into existing components and layouts. Performant** – Lightweight and optimized for UI responsiveness. Made the Svelte Way** - Mercury is built with Svelte’s philosophy at its core. Instead of mimicking patterns from other frameworks, it embraces Svelte’s strengths—reactivity, attachments, and transitions—without forcing external abstractions or workarounds that don't apply in the Svelte ecosystem.  Mercury makes advanced animations accessible to Svelte developers—without introducing unnecessary overhead or breaking the mental model of how Svelte works."},{"title":"Animate","href":"/docs/api/animate","description":"Easily animate your Svelte components using Mercury","content":"  import { Callout } from '@svecodocs/kit'  import * as Code from \"$lib/components/ui/code\"; let codeUsage =  `` let codeStagger =  `{#each { length: 3 }, i}   {/each}` let codeKeyframes =  `` let codeTransition = `      ` let codeRepetition = `      ` let codeSprings = `      `  Overview  The animate property lets you control animations applied to your components with Mercury.  Usage  Include the animate property within the mercury() attachment like this:  Supported Features  Mercury supports animations from popular engines like GSAP, Motion, and AnimeJS. To explore detailed capabilities, check your chosen engine’s documentation:  $2 $2 $2  Stagger  Instead of using stagger functions from the animation libraries, Mercury simplifies staggering animations by individually delaying elements:  Keyframes  Mercury supports keyframe animations by providing arrays of values:  Transition  Control the animation’s transition properties (duration, easing, repeat) with the transition parameter:  Easing  Easings control animation pacing, enhancing visual appeal. Mercury provides these built-in easings:  linear, easeIn, easeOut, easeInOut circIn, circOut,circInOut backIn, backOut, backInOut anticipate   Additionally, you can use custom easing functions provided by your selected animation library.  Repetition  Control how animations repeat with these parameters:  repeat: Number of repetitions (Infinity supported). repeatType: loop, reverese or mirror repeatDelay: Delay in seconds between repetitions.  Springs  Spring-based animations mimic physical springs, often providing the most natural animation experience:      Customize springs with  bounce: Controls spring bounce intensity.  damping: Adjusts resistance force.  mass: Sets the mass of the animated object.  stiffness: Defines spring stiffness.  velocity: Sets initial spring velocity.       Parameters might behave differently depending on the chosen animation library. Refer to its documentation for specific behaviors. "},{"title":"Engines","href":"/docs/api/engines","description":"Learn how to select, configure, and use animation engines with Mercury, and discover the enhanced capabilities Mercury provides.","content":"  import { Callout } from '@svecodocs/kit'  import * as Code from \"$lib/components/ui/code\";   let codeEngines = `  import {mercury, AnimeEngine} from '@omicrxn/mercury';     `  Overview  Mercury supports multiple animation engines, allowing you to select your preferred library—Motion (default), GSAP, or AnimeJS—and enrich their capabilities with additional features like gestures, layout animations, and presence animations.  Extended Functionality  In addition to the core functionalities provided by these libraries, Mercury offers unified, engine-agnostic features, including:  Gestures  Layout Animations  Presence (Enter/Exit Animations)   These features ensure consistency across different animation libraries.       Additional engine adapters are welcome! Feel free to contribute support for other animation libraries.  Selecting an Engine  By default, Mercury utilizes GSAP. To explicitly choose a different engine, use the engine parameter:      Available engine indentifiers:  GSAPEngine MotionEngine (default) AnimeEngine  Unified API  Mercury simplifies the animation workflow by providing a consistent API across all supported engines. This means uniform naming conventions and parameters, reducing complexity and making it easy to switch between engines without needing to learn multiple APIs.  For instance, some libraries use loop while others use repeat; Mercury standardizes these differences to ensure a smoother development experience."},{"title":"Gestures","href":"/docs/api/gestures","description":"Learn how to easily implement interactive gesture and scroll-based animations with Mercury.","content":"  import * as Code from \"$lib/components/ui/code\";   let codeHover = `     `  let codeTap = `     `  let codeScroll = `     `  Overview  Mercury provides robust support for interactive gesture and scroll-triggered animations, making it easy to enrich user experiences in your Svelte applications. Below, you’ll find detailed explanations and practical examples focusing on hover, tap, and scroll animations.  All gesture animations described below (hover, tap, and scroll) have their own independent transition. Additionally, the scroll animation supports extra parameters such as root, margin, and amount. If you don’t provide a specific transition, Mercury will use the default transition settings.  Gesture Animations  Gesture animations respond dynamically to user interactions such as hovering or tapping, providing immediate visual feedback that enhances interactivity.  Hover  Hover animations activate when a user moves their cursor over an element, creating intuitive and visually appealing interactions.  onHoverStart: function that runs when the mouse starts hovering the element. onHoverEnd: function that runs when the mouse goes outside the element. whileHover: animation run when the element is hovered.  Tap  Tap animations trigger on user click or touch interactions, creating engaging feedback that enhances tactile experiences.  onTapStart: function that runs when the mouse clicks the element. onTapEnd: function that runs when the click is up. whileTap: animation run when the element is tapped.  Scroll  Scroll-triggered animations activate as elements enter or leave the viewport, enhancing the visual flow and interactivity of content on scroll.  enter: animation that runs when the element goes into view. exit: animation that runs when the element exists the root. root: element to be used as scroll viewport.    "},{"title":"Layout Animations","href":"/docs/api/layout-animations","description":"Enhance your UI transitions with powerful layout animations using Mercury.","content":"  import { Callout } from '@svecodocs/kit'  import * as Code from \"$lib/components/ui/code\";   let codeBasicUsage = `      justify })}    class=\"box h-16 w-16 rounded-md border border-slate-500 bg-blue-200\"   />   {    flip(); //this toggles the parent element between justify-start and justify-end   }}   class=\"bg-slate-200\">Flip   `  let codeLayoutId = `  {#if toggle}    toggle })}    class=\"box h-16 w-16 rounded-md border border-slate-500 bg-blue-200\" {:else}    toggle })}    class=\"box h-24 w-24 rounded-md border border-slate-500 bg-blue-200\" {/if}   `  Overview  Layout animations enable you to animate properties and scenarios typically not supported by standard CSS animations. While standard animations effectively animate individual properties like opacity or scale, they can’t handle structural changes—such as switching flex-direction, updating grid-template-columns, or smoothly animating between two separate elements. Mercury’s layout animations effortlessly manage these complex cases.  Basic Usage  Use Mercury’s layout attachment independently or along the main Mercury attachment:        Svelte lacks automatic DOM change detection. And Mercury is created from the idea that it should be built upong Svelte core features and working in HTML Elements rather than having wrapper components. Thus, you must explicitly provide a state reference via the track parameter to trigger layout animations.  Layout ID (Shared Layout Animations)  To animate between two different elements, use the same layoutId in Mercury’s layout attachment. This smoothly transitions one element to another when state changes:      Both elements share the layoutId (test), enabling seamless and visually appealing transitions between the states."},{"title":"Presence (Enter / Exit)","href":"/docs/api/presence","description":"Effortlessly animate component mounting and unmounting using Mercury's presence features.","content":"  import { Callout } from '@svecodocs/kit'  import * as Code from \"$lib/components/ui/code\";   let codeExit = `  {#if show}    initial) ? 'transform:translateY(-25px)' : ''}    {@attach mercury({     animate: { opacity: 1, y: 0 },     transition: { type: 'spring', duration: 1, bounce: 0 }    })}    out:presence={{ opacity: 0, y: 25, popLayout: true, transition: { duration: 0.15 } }}    Example    {/if}   `  Overview  Mercury simplifies animating component entrances and exits, leveraging Svelte’s powerful transitions while reducing manual overhead. Unlike typical implementations where you wrap elements with specialized components, Mercury utilizes Svelte transitions directly, providing seamless integration and intuitive behavior out-of-the-box.  Enter animations  By default, Mercury animates from the element’s current style to the defined animate parameters, providing immediate entry animations. However, in scenarios where explicit control over initial states is required—particularly if you need different behaviors between initial render and subsequent renders—you can manually handle these styles.  Author Notes on Svelte Limitations:       Initially, the goal was to allow explicit initial styles directly within Mercury. However, there were two primary limitations with Svelte:     No First Render Control: Svelte does not currently provide a built-in mechanism to conditionally run intro transitions on the first render (see this issue)     Attachments Limitation: Styles cannot be applied via attachments before the component mounts, limiting pre-mount initialization capabilities. Due to these limitations, a manual workaround is necessary, as demonstrated below:    Mercury by default animates from the element style to the animate parameters. So you already get enter animations out of the box, however there are scenarios where explicitly note the initial styles so that Mercury animates from initial to animate parameters might be useful. The main example is if you want to have the default styles apply on the first run but then on the next ones go from initial to animate. The first thought was that like Exit animations that would be handled by in: transitions but Svelte doesn’t allow the ability to chose if they run on first render or not . The second thought was to apply the initial styles before the component mounts but that can’t be done in attachments as far as I’m concerned. So right now Enter animations are only from the element styles to animate. However if you need to have initial animation disabled on first render this is a solution:  Disabling Initial Animation on First Render  Here’s how to disable animations on the initial render but apply them subsequently:    import { presence, mercury } from '$lib/index.js';  import { onMount, untrack } from 'svelte';  let initial = $state(false);  onMount(() => {   initial = true;  });    initial) ? 'transform:translateY(-25px)' : ''}  {@attach mercury({   animate: { opacity: 1, y: 0 },   transition: { type: 'spring', duration: 1, bounce: 0 }  })}  Example  Explanation:  The span doesn’t animate initially.  After the first render, subsequent renders animate smoothly from y: -25px to y: 0px.  Exit Animations  Mercury provides smooth exit animations through its custom presence transition. Simply use it with Svelte’s built-in out: directive:  Explanation:  out:presence: Defines exit animations explicitly.  Parameters (opacity, y) specify the exit state of the animation.  The transition parameter customizes duration and easing behavior.  Exit Modes (sync, wait and popLayout)  If you are familiar with Motion, you will know that it has 3 main exit modes. While not as advanced as Motion’s.  Quoting $2  - “sync”: Children animate in/out as soon as they’re added/removed. - “wait”: The entering child will wait until the exiting child has animated out. Note: Currently only renders a single child at a time. - “popLayout”: Exiting children will be “popped” out of the page layout. This allows surrounding elements to move to their new layout immediately.  sync is the default behaviour in Mercury, but as you will notice. As you can see in the example above popLayout is a boolean parameter in the transition. So what happens with wait? Well as per Svelte documentation that behaviour is accomplished by default by wrapping the element in a {#key } block. So by leaving the transition by default, iff the element is wrapped by a {#key } block the behaviour will be Motion’s wait, but if it isn’t the behaviour will be Motion’s sync."}]